/*
 * generated by Xtext 2.32.0
 */
package cps.gameoflife.generator

import org.eclipse.emf.ecore.resource.Resource

import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import cps.gameoflife.lsjatl.Game
import cps.gameoflife.lsjatl.Rule
import cps.gameoflife.lsjatl.Condition

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class LsjatlGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val root = resource.allContents.head as Game;
		fsa.generateFile('RulesOfLife.java',
			'''package GameOfLife;
			
import java.awt.Point;
import java.util.ArrayList;
import java.util.Arrays;
			
public class RulesOfLife {
					public static int gridWidth = «root.grid.size.width»;
					public static int gridHeight = «root.grid.size.height»;
					public static ArrayList<Point> populatedCells = new ArrayList<Point>(
						Arrays.asList(
							«FOR populatedCell: Auxiliary.getStartingPoints(root.grid) SEPARATOR ', '»
								new Point(«populatedCell.x»,«populatedCell.y»)
							«ENDFOR»
						)
					);
					public static void computeSurvivors(boolean[][] gameBoard, ArrayList<Point> survivingCells) {
			        	// Iterate through the array, follow game of life rules
			       	 for (int i=1; i<gameBoard.length-1; i++) {
			            for (int j=1; j<gameBoard[0].length-1; j++) {
			                int surrounding = 0;
			                if (gameBoard[i-1][j-1]) { surrounding++; }
			                if (gameBoard[i-1][j])   { surrounding++; }
			                if (gameBoard[i-1][j+1]) { surrounding++; }
			                if (gameBoard[i][j-1])   { surrounding++; }
			                if (gameBoard[i][j+1])   { surrounding++; }
			                if (gameBoard[i+1][j-1]) { surrounding++; }
			                if (gameBoard[i+1][j])   { surrounding++; }
			                if (gameBoard[i+1][j+1]) { surrounding++; }
			''' +
			'''
							«FOR rule: Auxiliary.getRules(root)»
								«rule2Text(rule)»
							«ENDFOR»
			''' +
			'''			}
					}
					}
				}
			'''
		);
	}
	//Ncount is sus
	def static dispatch rule2Text(Rule rule)
	'''
		if ((«IF rule.state == "dead"»!«ENDIF»gameBoard[i][j]) && 
		«FOR condition: Auxiliary.getConditions(rule)»
		(surrounding «condition.boolOp» «condition.NCount») «IF condition.separator == "||"»||«ENDIF»«IF condition.separator == "&&"»&&«ENDIF»
		«ENDFOR»){
			«IF rule.result == "survives"»survivingCells.add(new Point(i-1,j-1));«ENDIF»
			«IF rule.result == "populates"»survivingCells.add(new Point(i-1,j-1));«ENDIF»
			«IF rule.result == "dies"»Point pointToRemove = new Point(i, j);
			                		survivingCells.removeIf(point -> point.equals(pointToRemove));«ENDIF»
		}
		''' 
}
