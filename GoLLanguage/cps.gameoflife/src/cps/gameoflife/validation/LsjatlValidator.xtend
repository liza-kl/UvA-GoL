/*
 * generated by Xtext 2.32.0
 */
package cps.gameoflife.validation

import org.eclipse.xtext.validation.Check
import cps.gameoflife.lsjatl.Grid
import cps.gameoflife.lsjatl.PopulatedCell
import cps.gameoflife.lsjatl.Game
import cps.gameoflife.lsjatl.Rule
import cps.gameoflife.lsjatl.Rules
import cps.gameoflife.lsjatl.Condition

import java.util.Arrays;
import java.util.List;
import java.util.HashSet
import cps.gameoflife.lsjatl.LsjatlPackage.Literals

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class LsjatlValidator extends AbstractLsjatlValidator {

	protected static val ISSUE_CODE_PREFIX = "cps.gameoflife.lsjatl.";
	public static val INVALID_RULE_OUTCOME = ISSUE_CODE_PREFIX + "InvalidRuleOutcome";
	public static val INVALID_SIGN = ISSUE_CODE_PREFIX + "InvalidSign";
	public static val String INVALID_DUPLICATION = "InvalidDuplication";
	

	@Check
	def checkIfValidNumberOfNeighbors(Condition condition) {
		if (condition.NCount > 8) {
			warning("The number of neighbors should not be greater than 8", null);
		}
		if (condition.NCount < 0) {
			error("The number of neighbors cannot be negative", null)

		}
	}

	@Check
	def checkForNegativeStartingCells(Game game)
	{
		for(var i = 0; i < game.grid.populatedCells.size(); i++)
		{
			if(game.grid.populatedCells.get(i).x < 0 || game.grid.populatedCells.get(i).y < 0 ) 
				{
					error("Cells must have positive coordinates", null, i);
					
				}
			 
		}
	}
	
	@Check
	def checkIfInitialCellsAreInGrid(Grid grid) {

		for (PopulatedCell cell : grid.populatedCells) {
			if (cell.x > grid.size.width || cell.y > grid.size.height || cell.x > grid.size.height ||
				cell.y > grid.size.height) {
				error("Cell cannot be outside the grid", null)
			}
		}
	}

	@Check
	def hasValidCellStates(Rules rules) {

		for (Rule rule : rules.rules) {
			val list = Arrays.asList('survives', 'dies', 'populates');
			if (!list.contains(rule.result)) {
				error("Cell needs to have a valid outcome", null)
			}
		}
	}

	@Check
	def hasValidOutcomeRules(Rules rules) {

		for (Rule rule : rules.rules) {
			val list = Arrays.asList('living', 'dead');
			if (!list.contains(rule.state)) {
				error("Cell needs to have a valid state e.g. living or dead", null)
			}
		}
	}

	@Check def doRulesExist(Rules rules) {
		if (rules.rules.size() == 0) {
			{
				warning("Game has no rules, so everyone and everything will die", null)
			}
		}
	}
	
	

	@Check
	def checkIdenticalRules(Rules rules) {
		var rulesList = rules.rules.toList();
		var ruleSet = new HashSet();

		for (rule : rulesList) {
			if (ruleSet.contains(rule)) {
				warning("There cannot be duplicate rules", Literals.RULES__RULES, INVALID_DUPLICATION);
			} else {
				ruleSet.add(rule);
			}
		}
	}
	
	
	
	@Check
	def checkDeadSurviving(Rules rules) {
		var rulesList = rules.rules.toList();

		for (rule : rulesList) {
			if (rule.state == 'dead' && rule.result == 'survives'){
				warning("A rule exists for a survival of dead cell.", null)
			}
		}
	}
	
	
	
	@Check
	def checkLivingPopulating(Rules rules) {
		var rulesList = rules.rules.toList();

		for (rule : rulesList) {
			if (rule.state == 'living' && rule.result == 'populates'){
				warning("A rule exists for populating a living cell. Only dead cells can be populated.", null)
			}
		}
	}
}
